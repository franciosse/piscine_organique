{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///media/franciosse/Data/Repos/piscine_organique/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\";\n\nimport { cn } from \"@/lib/utils\";\n\nfunction Input({ className, type, ...props }: React.ComponentProps<\"input\">) {\n  return (\n    <input\n      type={type}\n      data-slot=\"input\"\n      className={cn(\n        \"file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        \"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]\",\n        \"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n        className\n      )}\n      {...props}\n    />\n  );\n}\n\nexport { Input };\n"],"names":[],"mappings":";;;;AAEA;;;AAEA,SAAS,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAsC;IACzE,qBACE,8OAAC;QACC,MAAM;QACN,aAAU;QACV,WAAW,CAAA,GAAA,4GAAA,CAAA,KAAE,AAAD,EACV,mcACA,iFACA,0GACA;QAED,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 29, "column": 0}, "map": {"version":3,"sources":["file:///media/franciosse/Data/Repos/piscine_organique/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\";\n\nimport { cn } from \"@/lib/utils\";\n\nfunction Card({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card\"\n      className={cn(\n        \"bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm\",\n        className\n      )}\n      {...props}\n    />\n  );\n}\n\nfunction CardHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-header\"\n      className={cn(\n        \"@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6\",\n        className\n      )}\n      {...props}\n    />\n  );\n}\n\nfunction CardTitle({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-title\"\n      className={cn(\"leading-none font-semibold\", className)}\n      {...props}\n    />\n  );\n}\n\nfunction CardDescription({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-description\"\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...props}\n    />\n  );\n}\n\nfunction CardAction({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-action\"\n      className={cn(\n        \"col-start-2 row-span-2 row-start-1 self-start justify-self-end\",\n        className\n      )}\n      {...props}\n    />\n  );\n}\n\nfunction CardContent({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-content\"\n      className={cn(\"px-6\", className)}\n      {...props}\n    />\n  );\n}\n\nfunction CardFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-footer\"\n      className={cn(\"flex items-center px-6 [.border-t]:pt-6\", className)}\n      {...props}\n    />\n  );\n}\n\nexport {\n  Card,\n  CardHeader,\n  CardFooter,\n  CardTitle,\n  CardAction,\n  CardDescription,\n  CardContent\n};\n"],"names":[],"mappings":";;;;;;;;;;AAEA;;;AAEA,SAAS,KAAK,EAAE,SAAS,EAAE,GAAG,OAAoC;IAChE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,4GAAA,CAAA,KAAE,AAAD,EACV,qFACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,WAAW,EAAE,SAAS,EAAE,GAAG,OAAoC;IACtE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,4GAAA,CAAA,KAAE,AAAD,EACV,8JACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,UAAU,EAAE,SAAS,EAAE,GAAG,OAAoC;IACrE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,4GAAA,CAAA,KAAE,AAAD,EAAE,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,gBAAgB,EAAE,SAAS,EAAE,GAAG,OAAoC;IAC3E,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,4GAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,WAAW,EAAE,SAAS,EAAE,GAAG,OAAoC;IACtE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,4GAAA,CAAA,KAAE,AAAD,EACV,kEACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,YAAY,EAAE,SAAS,EAAE,GAAG,OAAoC;IACvE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,4GAAA,CAAA,KAAE,AAAD,EAAE,QAAQ;QACrB,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,WAAW,EAAE,SAAS,EAAE,GAAG,OAAoC;IACtE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,4GAAA,CAAA,KAAE,AAAD,EAAE,2CAA2C;QACxD,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///media/franciosse/Data/Repos/piscine_organique/components/ui/label.tsx"],"sourcesContent":["\"use client\";\n\nimport * as React from \"react\";\nimport { Label as LabelPrimitive } from \"radix-ui\";;\n\nimport { cn } from \"@/lib/utils\";\n\nfunction Label({\n  className,\n  ...props\n}: React.ComponentProps<typeof LabelPrimitive.Root>) {\n  return (\n    <LabelPrimitive.Root\n      data-slot=\"label\"\n      className={cn(\n        \"flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  );\n}\n\nexport { Label };\n"],"names":[],"mappings":";;;;AAGA;AAEA;AALA;;;;AAOA,SAAS,MAAM,EACb,SAAS,EACT,GAAG,OAC8C;IACjD,qBACE,8OAAC,kMAAA,CAAA,QAAc,CAAC,IAAI;QAClB,aAAU;QACV,WAAW,CAAA,GAAA,4GAAA,CAAA,KAAE,AAAD,EACV,uNACA;QAED,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 150, "column": 0}, "map": {"version":3,"sources":["file:///media/franciosse/Data/Repos/piscine_organique/app/%28login%29/actions.ts"],"sourcesContent":["'use server';\n\nimport { z } from 'zod';\nimport { and, eq, sql } from 'drizzle-orm';\nimport { db } from '@/lib/db/drizzle';\nimport {\n  User,\n  users,\n  teams,\n  teamMembers,\n  activityLogs,\n  type NewUser,\n  type NewTeam,\n  type NewTeamMember,\n  type NewActivityLog,\n  ActivityType,\n  invitations\n} from '@/lib/db/schema';\nimport { comparePasswords, hashPassword, setSession } from '@/lib/auth/session';\nimport { redirect } from 'next/navigation';\nimport { cookies } from 'next/headers';\nimport { createCheckoutSession } from '@/lib/payments/stripe';\nimport { getUser, getUserWithTeam } from '@/lib/db/queries';\nimport {\n  validatedAction,\n  validatedActionWithUser\n} from '@/lib/auth/middleware';\n\nasync function logActivity(\n  teamId: number | null | undefined,\n  userId: number,\n  type: ActivityType,\n  ipAddress?: string\n) {\n  if (teamId === null || teamId === undefined) {\n    return;\n  }\n  const newActivity: NewActivityLog = {\n    teamId,\n    userId,\n    action: type,\n    ipAddress: ipAddress || ''\n  };\n  await db.insert(activityLogs).values(newActivity);\n}\n\nconst signInSchema = z.object({\n  email: z.string().email().min(3).max(255),\n  password: z.string().min(8).max(100)\n});\n\nexport const signIn = validatedAction(signInSchema, async (data, formData) => {\n  const { email, password } = data;\n\n  const userWithTeam = await db\n    .select({\n      user: users,\n      team: teams\n    })\n    .from(users)\n    .leftJoin(teamMembers, eq(users.id, teamMembers.userId))\n    .leftJoin(teams, eq(teamMembers.teamId, teams.id))\n    .where(eq(users.email, email))\n    .limit(1);\n\n  if (userWithTeam.length === 0) {\n    return {\n      error: 'Invalid email or password. Please try again.',\n      email,\n      password\n    };\n  }\n\n  const { user: foundUser, team: foundTeam } = userWithTeam[0];\n\n  const isPasswordValid = await comparePasswords(\n    password,\n    foundUser.passwordHash\n  );\n\n  if (!isPasswordValid) {\n    return {\n      error: 'Invalid email or password. Please try again.',\n      email,\n      password\n    };\n  }\n\n  await Promise.all([\n    setSession(foundUser),\n    logActivity(foundTeam?.id, foundUser.id, ActivityType.SIGN_IN)\n  ]);\n\n  const redirectTo = formData.get('redirect') as string | null;\n  if (redirectTo === 'checkout') {\n    const priceId = formData.get('priceId') as string;\n    return createCheckoutSession({ team: foundTeam, priceId });\n  }\n\n  redirect('/dashboard');\n});\n\nconst signUpSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8),\n  inviteId: z.string().optional()\n});\n\nexport const signUp = validatedAction(signUpSchema, async (data, formData) => {\n  const { email, password, inviteId } = data;\n\n  const existingUser = await db\n    .select()\n    .from(users)\n    .where(eq(users.email, email))\n    .limit(1);\n\n  if (existingUser.length > 0) {\n    return {\n      error: 'Failed to create user. Please try again.',\n      email,\n      password\n    };\n  }\n\n  const passwordHash = await hashPassword(password);\n\n  const newUser: NewUser = {\n    email,\n    passwordHash,\n    role: 'owner' // Default role, will be overridden if there's an invitation\n  };\n\n  const [createdUser] = await db.insert(users).values(newUser).returning();\n\n  if (!createdUser) {\n    return {\n      error: 'Failed to create user. Please try again.',\n      email,\n      password\n    };\n  }\n\n  let teamId: number;\n  let userRole: string;\n  let createdTeam: typeof teams.$inferSelect | null = null;\n\n  if (inviteId) {\n    // Check if there's a valid invitation\n    const [invitation] = await db\n      .select()\n      .from(invitations)\n      .where(\n        and(\n          eq(invitations.id, parseInt(inviteId)),\n          eq(invitations.email, email),\n          eq(invitations.status, 'pending')\n        )\n      )\n      .limit(1);\n\n    if (invitation) {\n      teamId = invitation.teamId;\n      userRole = invitation.role;\n\n      await db\n        .update(invitations)\n        .set({ status: 'accepted' })\n        .where(eq(invitations.id, invitation.id));\n\n      await logActivity(teamId, createdUser.id, ActivityType.ACCEPT_INVITATION);\n\n      [createdTeam] = await db\n        .select()\n        .from(teams)\n        .where(eq(teams.id, teamId))\n        .limit(1);\n    } else {\n      return { error: 'Invalid or expired invitation.', email, password };\n    }\n  } else {\n    // Create a new team if there's no invitation\n    const newTeam: NewTeam = {\n      name: `${email}'s Team`\n    };\n\n    [createdTeam] = await db.insert(teams).values(newTeam).returning();\n\n    if (!createdTeam) {\n      return {\n        error: 'Failed to create team. Please try again.',\n        email,\n        password\n      };\n    }\n\n    teamId = createdTeam.id;\n    userRole = 'owner';\n\n    await logActivity(teamId, createdUser.id, ActivityType.CREATE_TEAM);\n  }\n\n  const newTeamMember: NewTeamMember = {\n    userId: createdUser.id,\n    teamId: teamId,\n    role: userRole\n  };\n\n  await Promise.all([\n    db.insert(teamMembers).values(newTeamMember),\n    logActivity(teamId, createdUser.id, ActivityType.SIGN_UP),\n    setSession(createdUser)\n  ]);\n\n  const redirectTo = formData.get('redirect') as string | null;\n  if (redirectTo === 'checkout') {\n    const priceId = formData.get('priceId') as string;\n    return createCheckoutSession({ team: createdTeam, priceId });\n  }\n\n  redirect('/dashboard');\n});\n\nexport async function signOut() {\n  const user = (await getUser()) as User;\n  const userWithTeam = await getUserWithTeam(user.id);\n  await logActivity(userWithTeam?.teamId, user.id, ActivityType.SIGN_OUT);\n  (await cookies()).delete('session');\n}\n\nconst updatePasswordSchema = z.object({\n  currentPassword: z.string().min(8).max(100),\n  newPassword: z.string().min(8).max(100),\n  confirmPassword: z.string().min(8).max(100)\n});\n\nexport const updatePassword = validatedActionWithUser(\n  updatePasswordSchema,\n  async (data, _, user) => {\n    const { currentPassword, newPassword, confirmPassword } = data;\n\n    const isPasswordValid = await comparePasswords(\n      currentPassword,\n      user.passwordHash\n    );\n\n    if (!isPasswordValid) {\n      return {\n        currentPassword,\n        newPassword,\n        confirmPassword,\n        error: 'Current password is incorrect.'\n      };\n    }\n\n    if (currentPassword === newPassword) {\n      return {\n        currentPassword,\n        newPassword,\n        confirmPassword,\n        error: 'New password must be different from the current password.'\n      };\n    }\n\n    if (confirmPassword !== newPassword) {\n      return {\n        currentPassword,\n        newPassword,\n        confirmPassword,\n        error: 'New password and confirmation password do not match.'\n      };\n    }\n\n    const newPasswordHash = await hashPassword(newPassword);\n    const userWithTeam = await getUserWithTeam(user.id);\n\n    await Promise.all([\n      db\n        .update(users)\n        .set({ passwordHash: newPasswordHash })\n        .where(eq(users.id, user.id)),\n      logActivity(userWithTeam?.teamId, user.id, ActivityType.UPDATE_PASSWORD)\n    ]);\n\n    return {\n      success: 'Password updated successfully.'\n    };\n  }\n);\n\nconst deleteAccountSchema = z.object({\n  password: z.string().min(8).max(100)\n});\n\nexport const deleteAccount = validatedActionWithUser(\n  deleteAccountSchema,\n  async (data, _, user) => {\n    const { password } = data;\n\n    const isPasswordValid = await comparePasswords(password, user.passwordHash);\n    if (!isPasswordValid) {\n      return {\n        password,\n        error: 'Incorrect password. Account deletion failed.'\n      };\n    }\n\n    const userWithTeam = await getUserWithTeam(user.id);\n\n    await logActivity(\n      userWithTeam?.teamId,\n      user.id,\n      ActivityType.DELETE_ACCOUNT\n    );\n\n    // Soft delete\n    await db\n      .update(users)\n      .set({\n        deletedAt: sql`CURRENT_TIMESTAMP`,\n        email: sql`CONCAT(email, '-', id, '-deleted')` // Ensure email uniqueness\n      })\n      .where(eq(users.id, user.id));\n\n    if (userWithTeam?.teamId) {\n      await db\n        .delete(teamMembers)\n        .where(\n          and(\n            eq(teamMembers.userId, user.id),\n            eq(teamMembers.teamId, userWithTeam.teamId)\n          )\n        );\n    }\n\n    (await cookies()).delete('session');\n    redirect('/sign-in');\n  }\n);\n\nconst updateAccountSchema = z.object({\n  name: z.string().min(1, 'Name is required').max(100),\n  email: z.string().email('Invalid email address')\n});\n\nexport const updateAccount = validatedActionWithUser(\n  updateAccountSchema,\n  async (data, _, user) => {\n    const { name, email } = data;\n    const userWithTeam = await getUserWithTeam(user.id);\n\n    await Promise.all([\n      db.update(users).set({ name, email }).where(eq(users.id, user.id)),\n      logActivity(userWithTeam?.teamId, user.id, ActivityType.UPDATE_ACCOUNT)\n    ]);\n\n    return { name, success: 'Account updated successfully.' };\n  }\n);\n\nconst removeTeamMemberSchema = z.object({\n  memberId: z.number()\n});\n\nexport const removeTeamMember = validatedActionWithUser(\n  removeTeamMemberSchema,\n  async (data, _, user) => {\n    const { memberId } = data;\n    const userWithTeam = await getUserWithTeam(user.id);\n\n    if (!userWithTeam?.teamId) {\n      return { error: 'User is not part of a team' };\n    }\n\n    await db\n      .delete(teamMembers)\n      .where(\n        and(\n          eq(teamMembers.id, memberId),\n          eq(teamMembers.teamId, userWithTeam.teamId)\n        )\n      );\n\n    await logActivity(\n      userWithTeam.teamId,\n      user.id,\n      ActivityType.REMOVE_TEAM_MEMBER\n    );\n\n    return { success: 'Team member removed successfully' };\n  }\n);\n\nconst inviteTeamMemberSchema = z.object({\n  email: z.string().email('Invalid email address'),\n  role: z.enum(['member', 'owner'])\n});\n\nexport const inviteTeamMember = validatedActionWithUser(\n  inviteTeamMemberSchema,\n  async (data, _, user) => {\n    const { email, role } = data;\n    const userWithTeam = await getUserWithTeam(user.id);\n\n    if (!userWithTeam?.teamId) {\n      return { error: 'User is not part of a team' };\n    }\n\n    const existingMember = await db\n      .select()\n      .from(users)\n      .leftJoin(teamMembers, eq(users.id, teamMembers.userId))\n      .where(\n        and(eq(users.email, email), eq(teamMembers.teamId, userWithTeam.teamId))\n      )\n      .limit(1);\n\n    if (existingMember.length > 0) {\n      return { error: 'User is already a member of this team' };\n    }\n\n    // Check if there's an existing invitation\n    const existingInvitation = await db\n      .select()\n      .from(invitations)\n      .where(\n        and(\n          eq(invitations.email, email),\n          eq(invitations.teamId, userWithTeam.teamId),\n          eq(invitations.status, 'pending')\n        )\n      )\n      .limit(1);\n\n    if (existingInvitation.length > 0) {\n      return { error: 'An invitation has already been sent to this email' };\n    }\n\n    // Create a new invitation\n    await db.insert(invitations).values({\n      teamId: userWithTeam.teamId,\n      email,\n      role,\n      invitedBy: user.id,\n      status: 'pending'\n    });\n\n    await logActivity(\n      userWithTeam.teamId,\n      user.id,\n      ActivityType.INVITE_TEAM_MEMBER\n    );\n\n    // TODO: Send invitation email and include ?inviteId={id} to sign-up URL\n    // await sendInvitationEmail(email, userWithTeam.team.name, role)\n\n    return { success: 'Invitation sent successfully' };\n  }\n);\n"],"names":[],"mappings":";;;;;;IA4Oa,iBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 161, "column": 0}, "map": {"version":3,"sources":["file:///media/franciosse/Data/Repos/piscine_organique/app/%28login%29/actions.ts"],"sourcesContent":["'use server';\n\nimport { z } from 'zod';\nimport { and, eq, sql } from 'drizzle-orm';\nimport { db } from '@/lib/db/drizzle';\nimport {\n  User,\n  users,\n  teams,\n  teamMembers,\n  activityLogs,\n  type NewUser,\n  type NewTeam,\n  type NewTeamMember,\n  type NewActivityLog,\n  ActivityType,\n  invitations\n} from '@/lib/db/schema';\nimport { comparePasswords, hashPassword, setSession } from '@/lib/auth/session';\nimport { redirect } from 'next/navigation';\nimport { cookies } from 'next/headers';\nimport { createCheckoutSession } from '@/lib/payments/stripe';\nimport { getUser, getUserWithTeam } from '@/lib/db/queries';\nimport {\n  validatedAction,\n  validatedActionWithUser\n} from '@/lib/auth/middleware';\n\nasync function logActivity(\n  teamId: number | null | undefined,\n  userId: number,\n  type: ActivityType,\n  ipAddress?: string\n) {\n  if (teamId === null || teamId === undefined) {\n    return;\n  }\n  const newActivity: NewActivityLog = {\n    teamId,\n    userId,\n    action: type,\n    ipAddress: ipAddress || ''\n  };\n  await db.insert(activityLogs).values(newActivity);\n}\n\nconst signInSchema = z.object({\n  email: z.string().email().min(3).max(255),\n  password: z.string().min(8).max(100)\n});\n\nexport const signIn = validatedAction(signInSchema, async (data, formData) => {\n  const { email, password } = data;\n\n  const userWithTeam = await db\n    .select({\n      user: users,\n      team: teams\n    })\n    .from(users)\n    .leftJoin(teamMembers, eq(users.id, teamMembers.userId))\n    .leftJoin(teams, eq(teamMembers.teamId, teams.id))\n    .where(eq(users.email, email))\n    .limit(1);\n\n  if (userWithTeam.length === 0) {\n    return {\n      error: 'Invalid email or password. Please try again.',\n      email,\n      password\n    };\n  }\n\n  const { user: foundUser, team: foundTeam } = userWithTeam[0];\n\n  const isPasswordValid = await comparePasswords(\n    password,\n    foundUser.passwordHash\n  );\n\n  if (!isPasswordValid) {\n    return {\n      error: 'Invalid email or password. Please try again.',\n      email,\n      password\n    };\n  }\n\n  await Promise.all([\n    setSession(foundUser),\n    logActivity(foundTeam?.id, foundUser.id, ActivityType.SIGN_IN)\n  ]);\n\n  const redirectTo = formData.get('redirect') as string | null;\n  if (redirectTo === 'checkout') {\n    const priceId = formData.get('priceId') as string;\n    return createCheckoutSession({ team: foundTeam, priceId });\n  }\n\n  redirect('/dashboard');\n});\n\nconst signUpSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8),\n  inviteId: z.string().optional()\n});\n\nexport const signUp = validatedAction(signUpSchema, async (data, formData) => {\n  const { email, password, inviteId } = data;\n\n  const existingUser = await db\n    .select()\n    .from(users)\n    .where(eq(users.email, email))\n    .limit(1);\n\n  if (existingUser.length > 0) {\n    return {\n      error: 'Failed to create user. Please try again.',\n      email,\n      password\n    };\n  }\n\n  const passwordHash = await hashPassword(password);\n\n  const newUser: NewUser = {\n    email,\n    passwordHash,\n    role: 'owner' // Default role, will be overridden if there's an invitation\n  };\n\n  const [createdUser] = await db.insert(users).values(newUser).returning();\n\n  if (!createdUser) {\n    return {\n      error: 'Failed to create user. Please try again.',\n      email,\n      password\n    };\n  }\n\n  let teamId: number;\n  let userRole: string;\n  let createdTeam: typeof teams.$inferSelect | null = null;\n\n  if (inviteId) {\n    // Check if there's a valid invitation\n    const [invitation] = await db\n      .select()\n      .from(invitations)\n      .where(\n        and(\n          eq(invitations.id, parseInt(inviteId)),\n          eq(invitations.email, email),\n          eq(invitations.status, 'pending')\n        )\n      )\n      .limit(1);\n\n    if (invitation) {\n      teamId = invitation.teamId;\n      userRole = invitation.role;\n\n      await db\n        .update(invitations)\n        .set({ status: 'accepted' })\n        .where(eq(invitations.id, invitation.id));\n\n      await logActivity(teamId, createdUser.id, ActivityType.ACCEPT_INVITATION);\n\n      [createdTeam] = await db\n        .select()\n        .from(teams)\n        .where(eq(teams.id, teamId))\n        .limit(1);\n    } else {\n      return { error: 'Invalid or expired invitation.', email, password };\n    }\n  } else {\n    // Create a new team if there's no invitation\n    const newTeam: NewTeam = {\n      name: `${email}'s Team`\n    };\n\n    [createdTeam] = await db.insert(teams).values(newTeam).returning();\n\n    if (!createdTeam) {\n      return {\n        error: 'Failed to create team. Please try again.',\n        email,\n        password\n      };\n    }\n\n    teamId = createdTeam.id;\n    userRole = 'owner';\n\n    await logActivity(teamId, createdUser.id, ActivityType.CREATE_TEAM);\n  }\n\n  const newTeamMember: NewTeamMember = {\n    userId: createdUser.id,\n    teamId: teamId,\n    role: userRole\n  };\n\n  await Promise.all([\n    db.insert(teamMembers).values(newTeamMember),\n    logActivity(teamId, createdUser.id, ActivityType.SIGN_UP),\n    setSession(createdUser)\n  ]);\n\n  const redirectTo = formData.get('redirect') as string | null;\n  if (redirectTo === 'checkout') {\n    const priceId = formData.get('priceId') as string;\n    return createCheckoutSession({ team: createdTeam, priceId });\n  }\n\n  redirect('/dashboard');\n});\n\nexport async function signOut() {\n  const user = (await getUser()) as User;\n  const userWithTeam = await getUserWithTeam(user.id);\n  await logActivity(userWithTeam?.teamId, user.id, ActivityType.SIGN_OUT);\n  (await cookies()).delete('session');\n}\n\nconst updatePasswordSchema = z.object({\n  currentPassword: z.string().min(8).max(100),\n  newPassword: z.string().min(8).max(100),\n  confirmPassword: z.string().min(8).max(100)\n});\n\nexport const updatePassword = validatedActionWithUser(\n  updatePasswordSchema,\n  async (data, _, user) => {\n    const { currentPassword, newPassword, confirmPassword } = data;\n\n    const isPasswordValid = await comparePasswords(\n      currentPassword,\n      user.passwordHash\n    );\n\n    if (!isPasswordValid) {\n      return {\n        currentPassword,\n        newPassword,\n        confirmPassword,\n        error: 'Current password is incorrect.'\n      };\n    }\n\n    if (currentPassword === newPassword) {\n      return {\n        currentPassword,\n        newPassword,\n        confirmPassword,\n        error: 'New password must be different from the current password.'\n      };\n    }\n\n    if (confirmPassword !== newPassword) {\n      return {\n        currentPassword,\n        newPassword,\n        confirmPassword,\n        error: 'New password and confirmation password do not match.'\n      };\n    }\n\n    const newPasswordHash = await hashPassword(newPassword);\n    const userWithTeam = await getUserWithTeam(user.id);\n\n    await Promise.all([\n      db\n        .update(users)\n        .set({ passwordHash: newPasswordHash })\n        .where(eq(users.id, user.id)),\n      logActivity(userWithTeam?.teamId, user.id, ActivityType.UPDATE_PASSWORD)\n    ]);\n\n    return {\n      success: 'Password updated successfully.'\n    };\n  }\n);\n\nconst deleteAccountSchema = z.object({\n  password: z.string().min(8).max(100)\n});\n\nexport const deleteAccount = validatedActionWithUser(\n  deleteAccountSchema,\n  async (data, _, user) => {\n    const { password } = data;\n\n    const isPasswordValid = await comparePasswords(password, user.passwordHash);\n    if (!isPasswordValid) {\n      return {\n        password,\n        error: 'Incorrect password. Account deletion failed.'\n      };\n    }\n\n    const userWithTeam = await getUserWithTeam(user.id);\n\n    await logActivity(\n      userWithTeam?.teamId,\n      user.id,\n      ActivityType.DELETE_ACCOUNT\n    );\n\n    // Soft delete\n    await db\n      .update(users)\n      .set({\n        deletedAt: sql`CURRENT_TIMESTAMP`,\n        email: sql`CONCAT(email, '-', id, '-deleted')` // Ensure email uniqueness\n      })\n      .where(eq(users.id, user.id));\n\n    if (userWithTeam?.teamId) {\n      await db\n        .delete(teamMembers)\n        .where(\n          and(\n            eq(teamMembers.userId, user.id),\n            eq(teamMembers.teamId, userWithTeam.teamId)\n          )\n        );\n    }\n\n    (await cookies()).delete('session');\n    redirect('/sign-in');\n  }\n);\n\nconst updateAccountSchema = z.object({\n  name: z.string().min(1, 'Name is required').max(100),\n  email: z.string().email('Invalid email address')\n});\n\nexport const updateAccount = validatedActionWithUser(\n  updateAccountSchema,\n  async (data, _, user) => {\n    const { name, email } = data;\n    const userWithTeam = await getUserWithTeam(user.id);\n\n    await Promise.all([\n      db.update(users).set({ name, email }).where(eq(users.id, user.id)),\n      logActivity(userWithTeam?.teamId, user.id, ActivityType.UPDATE_ACCOUNT)\n    ]);\n\n    return { name, success: 'Account updated successfully.' };\n  }\n);\n\nconst removeTeamMemberSchema = z.object({\n  memberId: z.number()\n});\n\nexport const removeTeamMember = validatedActionWithUser(\n  removeTeamMemberSchema,\n  async (data, _, user) => {\n    const { memberId } = data;\n    const userWithTeam = await getUserWithTeam(user.id);\n\n    if (!userWithTeam?.teamId) {\n      return { error: 'User is not part of a team' };\n    }\n\n    await db\n      .delete(teamMembers)\n      .where(\n        and(\n          eq(teamMembers.id, memberId),\n          eq(teamMembers.teamId, userWithTeam.teamId)\n        )\n      );\n\n    await logActivity(\n      userWithTeam.teamId,\n      user.id,\n      ActivityType.REMOVE_TEAM_MEMBER\n    );\n\n    return { success: 'Team member removed successfully' };\n  }\n);\n\nconst inviteTeamMemberSchema = z.object({\n  email: z.string().email('Invalid email address'),\n  role: z.enum(['member', 'owner'])\n});\n\nexport const inviteTeamMember = validatedActionWithUser(\n  inviteTeamMemberSchema,\n  async (data, _, user) => {\n    const { email, role } = data;\n    const userWithTeam = await getUserWithTeam(user.id);\n\n    if (!userWithTeam?.teamId) {\n      return { error: 'User is not part of a team' };\n    }\n\n    const existingMember = await db\n      .select()\n      .from(users)\n      .leftJoin(teamMembers, eq(users.id, teamMembers.userId))\n      .where(\n        and(eq(users.email, email), eq(teamMembers.teamId, userWithTeam.teamId))\n      )\n      .limit(1);\n\n    if (existingMember.length > 0) {\n      return { error: 'User is already a member of this team' };\n    }\n\n    // Check if there's an existing invitation\n    const existingInvitation = await db\n      .select()\n      .from(invitations)\n      .where(\n        and(\n          eq(invitations.email, email),\n          eq(invitations.teamId, userWithTeam.teamId),\n          eq(invitations.status, 'pending')\n        )\n      )\n      .limit(1);\n\n    if (existingInvitation.length > 0) {\n      return { error: 'An invitation has already been sent to this email' };\n    }\n\n    // Create a new invitation\n    await db.insert(invitations).values({\n      teamId: userWithTeam.teamId,\n      email,\n      role,\n      invitedBy: user.id,\n      status: 'pending'\n    });\n\n    await logActivity(\n      userWithTeam.teamId,\n      user.id,\n      ActivityType.INVITE_TEAM_MEMBER\n    );\n\n    // TODO: Send invitation email and include ?inviteId={id} to sign-up URL\n    // await sendInvitationEmail(email, userWithTeam.team.name, role)\n\n    return { success: 'Invitation sent successfully' };\n  }\n);\n"],"names":[],"mappings":";;;;;;IAsSa,gBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///media/franciosse/Data/Repos/piscine_organique/app/%28dashboard%29/dashboard/security/page.tsx"],"sourcesContent":["'use client';\n\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Label } from '@/components/ui/label';\nimport { Lock, Trash2, Loader2 } from 'lucide-react';\nimport { useActionState } from 'react';\nimport { updatePassword, deleteAccount } from '@/app/(login)/actions';\n\ntype PasswordState = {\n  currentPassword?: string;\n  newPassword?: string;\n  confirmPassword?: string;\n  error?: string;\n  success?: string;\n};\n\ntype DeleteState = {\n  password?: string;\n  error?: string;\n  success?: string;\n};\n\nexport default function SecurityPage() {\n  const [passwordState, passwordAction, isPasswordPending] = useActionState<\n    PasswordState,\n    FormData\n  >(updatePassword, {});\n\n  const [deleteState, deleteAction, isDeletePending] = useActionState<\n    DeleteState,\n    FormData\n  >(deleteAccount, {});\n\n  return (\n    <section className=\"flex-1 p-4 lg:p-8\">\n      <h1 className=\"text-lg lg:text-2xl font-medium bold text-gray-900 mb-6\">\n        Security Settings\n      </h1>\n      <Card className=\"mb-8\">\n        <CardHeader>\n          <CardTitle>Password</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <form className=\"space-y-4\" action={passwordAction}>\n            <div>\n              <Label htmlFor=\"current-password\" className=\"mb-2\">\n                Current Password\n              </Label>\n              <Input\n                id=\"current-password\"\n                name=\"currentPassword\"\n                type=\"password\"\n                autoComplete=\"current-password\"\n                required\n                minLength={8}\n                maxLength={100}\n                defaultValue={passwordState.currentPassword}\n              />\n            </div>\n            <div>\n              <Label htmlFor=\"new-password\" className=\"mb-2\">\n                New Password\n              </Label>\n              <Input\n                id=\"new-password\"\n                name=\"newPassword\"\n                type=\"password\"\n                autoComplete=\"new-password\"\n                required\n                minLength={8}\n                maxLength={100}\n                defaultValue={passwordState.newPassword}\n              />\n            </div>\n            <div>\n              <Label htmlFor=\"confirm-password\" className=\"mb-2\">\n                Confirm New Password\n              </Label>\n              <Input\n                id=\"confirm-password\"\n                name=\"confirmPassword\"\n                type=\"password\"\n                required\n                minLength={8}\n                maxLength={100}\n                defaultValue={passwordState.confirmPassword}\n              />\n            </div>\n            {passwordState.error && (\n              <p className=\"text-red-500 text-sm\">{passwordState.error}</p>\n            )}\n            {passwordState.success && (\n              <p className=\"text-green-500 text-sm\">{passwordState.success}</p>\n            )}\n            <Button\n              type=\"submit\"\n              className=\"bg-orange-500 hover:bg-orange-600 text-white\"\n              disabled={isPasswordPending}\n            >\n              {isPasswordPending ? (\n                <>\n                  <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                  Updating...\n                </>\n              ) : (\n                <>\n                  <Lock className=\"mr-2 h-4 w-4\" />\n                  Update Password\n                </>\n              )}\n            </Button>\n          </form>\n        </CardContent>\n      </Card>\n\n      <Card>\n        <CardHeader>\n          <CardTitle>Delete Account</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <p className=\"text-sm text-gray-500 mb-4\">\n            Account deletion is non-reversable. Please proceed with caution.\n          </p>\n          <form action={deleteAction} className=\"space-y-4\">\n            <div>\n              <Label htmlFor=\"delete-password\" className=\"mb-2\">\n                Confirm Password\n              </Label>\n              <Input\n                id=\"delete-password\"\n                name=\"password\"\n                type=\"password\"\n                required\n                minLength={8}\n                maxLength={100}\n                defaultValue={deleteState.password}\n              />\n            </div>\n            {deleteState.error && (\n              <p className=\"text-red-500 text-sm\">{deleteState.error}</p>\n            )}\n            <Button\n              type=\"submit\"\n              variant=\"destructive\"\n              className=\"bg-red-600 hover:bg-red-700\"\n              disabled={isDeletePending}\n            >\n              {isDeletePending ? (\n                <>\n                  <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                  Deleting...\n                </>\n              ) : (\n                <>\n                  <Trash2 className=\"mr-2 h-4 w-4\" />\n                  Delete Account\n                </>\n              )}\n            </Button>\n          </form>\n        </CardContent>\n      </Card>\n    </section>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 516, "column": 0}, "map": {"version":3,"sources":["file:///media/franciosse/Data/Repos/piscine_organique/node_modules/%40radix-ui/react-label/src/label.tsx"],"sourcesContent":["import * as React from 'react';\nimport { Primitive } from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * Label\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAME = 'Label';\n\ntype LabelElement = React.ComponentRef<typeof Primitive.label>;\ntype PrimitiveLabelProps = React.ComponentPropsWithoutRef<typeof Primitive.label>;\ninterface LabelProps extends PrimitiveLabelProps {}\n\nconst Label = React.forwardRef<LabelElement, LabelProps>((props, forwardedRef) => {\n  return (\n    <Primitive.label\n      {...props}\n      ref={forwardedRef}\n      onMouseDown={(event) => {\n        // only prevent text selection if clicking inside the label itself\n        const target = event.target as HTMLElement;\n        if (target.closest('button, input, select, textarea')) return;\n\n        props.onMouseDown?.(event);\n        // prevent text selection when double clicking label\n        if (!event.defaultPrevented && event.detail > 1) event.preventDefault();\n      }}\n    />\n  );\n});\n\nLabel.displayName = NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Label;\n\nexport {\n  Label,\n  //\n  Root,\n};\nexport type { LabelProps };\n"],"names":[],"mappings":";;;;;AAAA,YAAY,WAAW;AACvB,SAAS,iBAAiB;AActB;;;;;AARJ,IAAM,OAAO;AAMb,IAAM,kNAAc,aAAA,EAAqC,CAAC,OAAO,iBAAiB;IAChF,OACE,aAAA,GAAA,CAAA,GAAA,uNAAA,CAAA,MAAA,wKAAC,YAAA,CAAU,KAAA,EAAV;QACE,GAAG,KAAA;QACJ,KAAK;QACL,aAAa,CAAC,UAAU;YAEtB,MAAM,SAAS,MAAM,MAAA;YACrB,IAAI,OAAO,OAAA,CAAQ,iCAAiC,EAAG,CAAA;YAEvD,MAAM,WAAA,GAAc,KAAK;YAEzB,IAAI,CAAC,MAAM,gBAAA,IAAoB,MAAM,MAAA,GAAS,EAAG,CAAA,MAAM,cAAA,CAAe;QACxE;IAAA;AAGN,CAAC;AAED,MAAM,WAAA,GAAc;AAIpB,IAAM,OAAO","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 557, "column": 0}, "map": {"version":3,"file":"lock.js","sources":["file:///media/franciosse/Data/Repos/piscine_organique/node_modules/lucide-react/src/icons/lock.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['rect', { width: '18', height: '11', x: '3', y: '11', rx: '2', ry: '2', key: '1w4ew1' }],\n  ['path', { d: 'M7 11V7a5 5 0 0 1 10 0v4', key: 'fwvmzm' }],\n];\n\n/**\n * @component @name Lock\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cmVjdCB3aWR0aD0iMTgiIGhlaWdodD0iMTEiIHg9IjMiIHk9IjExIiByeD0iMiIgcnk9IjIiIC8+CiAgPHBhdGggZD0iTTcgMTFWN2E1IDUgMCAwIDEgMTAgMHY0IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/lock\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Lock = createLucideIcon('lock', __iconNode);\n\nexport default Lock;\n"],"names":[],"mappings":";;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAuB,CAAA,CAAA,CAAA;IAClC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA;QAAA,CAAA;YAAE,KAAO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM;YAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAQ,CAAA,CAAA,CAAA,CAAA,CAAM,CAAA;YAAA,CAAA,EAAG,CAAK,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAG;YAAM,CAAI,CAAA,CAAA,CAAA,GAAA,CAAK;YAAA,CAAA,EAAI,CAAA,CAAA,CAAA,CAAK,CAAA;YAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACxF;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA;QAAA,CAAA;YAAE,GAAG,CAA4B,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA;CAC3D;AAaM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAO,CAAA,wKAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAiB,AAAjB,CAAA,CAAA,AAAiB,CAAjB,AAAiB,CAAjB,AAAiB,CAAA,CAAA,CAAA,CAAA,EAAQ,CAAU,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 604, "column": 0}, "map": {"version":3,"file":"trash-2.js","sources":["file:///media/franciosse/Data/Repos/piscine_organique/node_modules/lucide-react/src/icons/trash-2.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M3 6h18', key: 'd0wm0j' }],\n  ['path', { d: 'M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6', key: '4alrt4' }],\n  ['path', { d: 'M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2', key: 'v07s0e' }],\n  ['line', { x1: '10', x2: '10', y1: '11', y2: '17', key: '1uufr5' }],\n  ['line', { x1: '14', x2: '14', y1: '11', y2: '17', key: 'xtxkd' }],\n];\n\n/**\n * @component @name Trash2\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMyA2aDE4IiAvPgogIDxwYXRoIGQ9Ik0xOSA2djE0YzAgMS0xIDItMiAySDdjLTEgMC0yLTEtMi0yVjYiIC8+CiAgPHBhdGggZD0iTTggNlY0YzAtMSAxLTIgMi0yaDRjMSAwIDIgMSAyIDJ2MiIgLz4KICA8bGluZSB4MT0iMTAiIHgyPSIxMCIgeTE9IjExIiB5Mj0iMTciIC8+CiAgPGxpbmUgeDE9IjE0IiB4Mj0iMTQiIHkxPSIxMSIgeTI9IjE3IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/trash-2\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Trash2 = createLucideIcon('trash-2', __iconNode);\n\nexport default Trash2;\n"],"names":[],"mappings":";;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAuB,CAAA,CAAA,CAAA;IAClC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA;QAAA,CAAA;YAAE,GAAG,CAAW,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA;IACxC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA;QAAA,CAAA;YAAE,GAAG,CAAyC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA;IACtE;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA;QAAA,CAAA;YAAE,GAAG,CAAsC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA;IACnE;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAE;YAAA,CAAA,CAAA,EAAI,CAAM,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAI,CAAM,CAAA,CAAA,CAAA,CAAA;YAAA,EAAA,CAAI,CAAA,CAAA,CAAA,CAAA,CAAM,CAAA;YAAA,CAAA,CAAA,CAAI,CAAA,CAAA,CAAA,CAAA,CAAM;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA;IAClE;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAE;YAAA,CAAA,CAAA,EAAI,CAAM,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAI,CAAM,CAAA,CAAA,CAAA,CAAA;YAAA,EAAA,CAAI,CAAA,CAAA,CAAA,CAAA,CAAM,CAAA;YAAA,CAAA,CAAA,CAAI,CAAA,CAAA,CAAA,CAAA,CAAM;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAS;KAAA;CACnE;AAaM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAS,CAAA,wKAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,AAAiB,CAAjB,CAAA,AAAiB,CAAjB,AAAiB,CAAjB,AAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAW,CAAU,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 673, "column": 0}, "map": {"version":3,"file":"loader-circle.js","sources":["file:///media/franciosse/Data/Repos/piscine_organique/node_modules/lucide-react/src/icons/loader-circle.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [['path', { d: 'M21 12a9 9 0 1 1-6.219-8.56', key: '13zald' }]];\n\n/**\n * @component @name LoaderCircle\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjEgMTJhOSA5IDAgMSAxLTYuMjE5LTguNTYiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/loader-circle\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst LoaderCircle = createLucideIcon('loader-circle', __iconNode);\n\nexport default LoaderCircle;\n"],"names":[],"mappings":";;;;;;;;;;;AAGa,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,UAAA,CAAuB,CAAA,CAAA;IAAC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ;QAAA,CAAE;YAAA,EAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAA+B;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK,CAAS,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAC;KAAC;CAAA;AAa5F,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,YAAA,CAAe,CAAA,wKAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,AAAiB,CAAjB,CAAA,AAAiB,CAAjB,AAAiB,CAAjB,AAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAiB,CAAU,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA","ignoreList":[0],"debugId":null}}]
}